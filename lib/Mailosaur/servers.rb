# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Mailosaur
  #
  # # Introduction
  #
  # This is an overview of the Mailosaur API. This API a RESTful JSON interface
  # with predictable, resource-oriented URLs. We make use of HTTP response
  # codes to indicate
  # API errors.
  #
  # We use built-in HTTP features, like HTTP authentication and HTTP verbs,
  # which are understood
  # by off-the-shelf HTTP clients.
  #
  # [Official client libraries](/docs/client-libraries/) available for most
  # popular languages.
  #
  # # Authentication
  #
  # Authenticate your account when using the API by including your API key in
  # the request.
  # You can [manage your API keys](/app/account/api-access/) in the Mailosaur
  # UI. Your API key carrys many privileges,
  # so be sure to keep it secret! Do not share your API key in
  # publicly-accessible areas such
  # GitHub, client-side code, and so on.
  #
  # All API requests must be made over HTTPS. Calls made over plain HTTP will
  # fail.
  # API requests without authentication will also fail.
  #
  # # Errors
  #
  # ## HTTP status codes
  #
  # Mailosaur uses conventional HTTP response codes to indicate the success or
  # failure of an
  # API request. In general, codes in the `2xx` range indicate success, codes
  # in the `4xx` range
  # indicate an error that failed given the information provided (e.g., a
  # required parameter
  # was omitted), and codes in the `5xx` range indicate an error with
  # Mailosaur's servers (give us a shout in the unlikely event that you see one
  # of those).
  #
  # | Code | Description |
  # |---|---|
  # | 200 - OK | Request was successful. |
  # | 204 - No Content | Request was successful, no response content. |
  # | 400 - Bad Request | The request could be handled, often due to missing a
  # required parameter. |
  # | 401 - Unauthorized | No valid API key provided. |
  # | 404 - Not Found | The requested resource doesn't exist. |
  # | 5XX - Server Errors | Something went wrong at Mailosaur. (Give us a
  # shout). |
  #
  # ## Error handling
  #
  # In of an error the server will return as much information as possible. In
  # the case of a `401` or
  # `404` error the status code gives as much information as you'd need. But
  # for `400` errors
  # Mailosaur will return a JSON object containing the structure below.
  #
  # Note that our client libraries convert responses to appropriate
  # language-specific objects.
  #
  # | Property | Description |
  # |---|---|
  # | `type` | The type of error returned. Can be: api_connection_error,
  # api_error, authentication_error, card_error, idempotency_error
  # invalid_request_error, or rate_limit_error. |
  # | `message` | A human-readable message providing more details about the
  # error. |
  # | `parameters` | A JSON object containing a key for each property name at
  # fault, with a human-readable message per field |
  # | `model` | The request model that we sent and failed to be processed |
  #
  class Servers

    #
    # Creates and initializes a new instance of the Servers class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [MailosaurBaseClient] reference to the MailosaurBaseClient
    attr_reader :client

    #
    # List all servers
    #
    # Returns a list of your virtual SMTP servers. Servers are returned sorted in
    # alphabetical order.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ServerListResult] operation results.
    #
    def list(custom_headers:nil)
      response = list_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all servers
    #
    # Returns a list of your virtual SMTP servers. Servers are returned sorted in
    # alphabetical order.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_with_http_info(custom_headers:nil)
      list_async(custom_headers:custom_headers).value!
    end

    #
    # List all servers
    #
    # Returns a list of your virtual SMTP servers. Servers are returned sorted in
    # alphabetical order.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/servers'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::ServerListResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create a server
    #
    # Creates a new virtual SMTP server and returns it.
    #
    # @param server_create_options [ServerCreateOptions]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Server] operation results.
    #
    def create(server_create_options, custom_headers:nil)
      response = create_async(server_create_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create a server
    #
    # Creates a new virtual SMTP server and returns it.
    #
    # @param server_create_options [ServerCreateOptions]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_with_http_info(server_create_options, custom_headers:nil)
      create_async(server_create_options, custom_headers:custom_headers).value!
    end

    #
    # Create a server
    #
    # Creates a new virtual SMTP server and returns it.
    #
    # @param server_create_options [ServerCreateOptions]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_async(server_create_options, custom_headers:nil)
      fail ArgumentError, 'server_create_options is nil' if server_create_options.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Mailosaur::Models::ServerCreateOptions.mapper()
      request_content = @client.serialize(request_mapper,  server_create_options)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'api/servers'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::Server.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieve a server
    #
    # Retrieves the detail for a single server. Simply supply the unique identifier
    # for the required server.
    #
    # @param id [String] The identifier of the server to be retrieved.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Server] operation results.
    #
    def get(id, custom_headers:nil)
      response = get_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieve a server
    #
    # Retrieves the detail for a single server. Simply supply the unique identifier
    # for the required server.
    #
    # @param id [String] The identifier of the server to be retrieved.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_with_http_info(id, custom_headers:nil)
      get_async(id, custom_headers:custom_headers).value!
    end

    #
    # Retrieve a server
    #
    # Retrieves the detail for a single server. Simply supply the unique identifier
    # for the required server.
    #
    # @param id [String] The identifier of the server to be retrieved.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/servers/{id}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::Server.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Update a server
    #
    # Updats a single server and returns it.
    #
    # @param id [String] The identifier of the server to be updated.
    # @param server [Server]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Server] operation results.
    #
    def update(id, server, custom_headers:nil)
      response = update_async(id, server, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Update a server
    #
    # Updats a single server and returns it.
    #
    # @param id [String] The identifier of the server to be updated.
    # @param server [Server]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_with_http_info(id, server, custom_headers:nil)
      update_async(id, server, custom_headers:custom_headers).value!
    end

    #
    # Update a server
    #
    # Updats a single server and returns it.
    #
    # @param id [String] The identifier of the server to be updated.
    # @param server [Server]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_async(id, server, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'server is nil' if server.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Mailosaur::Models::Server.mapper()
      request_content = @client.serialize(request_mapper,  server)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'api/servers/{id}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::Server.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete a server
    #
    # Permanently deletes a server. This operation cannot be undone. Also deletes
    # all messages and associated attachments within the server.
    #
    # @param id [String] The identifier of the server to be deleted.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete(id, custom_headers:nil)
      response = delete_async(id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete a server
    #
    # Permanently deletes a server. This operation cannot be undone. Also deletes
    # all messages and associated attachments within the server.
    #
    # @param id [String] The identifier of the server to be deleted.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_with_http_info(id, custom_headers:nil)
      delete_async(id, custom_headers:custom_headers).value!
    end

    #
    # Delete a server
    #
    # Permanently deletes a server. This operation cannot be undone. Also deletes
    # all messages and associated attachments within the server.
    #
    # @param id [String] The identifier of the server to be deleted.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/servers/{id}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end


        result
      end

      promise.execute
    end

  end
end

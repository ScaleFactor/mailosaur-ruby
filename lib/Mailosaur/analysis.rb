# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Mailosaur
  #
  # # Introduction
  #
  # This is an overview of the Mailosaur API. This API a RESTful JSON interface
  # with predictable, resource-oriented URLs. We make use of HTTP response
  # codes to indicate
  # API errors.
  #
  # We use built-in HTTP features, like HTTP authentication and HTTP verbs,
  # which are understood
  # by off-the-shelf HTTP clients.
  #
  # [Official client libraries](/docs/client-libraries/) available for most
  # popular languages.
  #
  # # Authentication
  #
  # Authenticate your account when using the API by including your API key in
  # the request.
  # You can [manage your API keys](/app/account/api-access/) in the Mailosaur
  # UI. Your API key carrys many privileges,
  # so be sure to keep it secret! Do not share your API key in
  # publicly-accessible areas such
  # GitHub, client-side code, and so on.
  #
  # All API requests must be made over HTTPS. Calls made over plain HTTP will
  # fail.
  # API requests without authentication will also fail.
  #
  # # Errors
  #
  # ## HTTP status codes
  #
  # Mailosaur uses conventional HTTP response codes to indicate the success or
  # failure of an
  # API request. In general, codes in the `2xx` range indicate success, codes
  # in the `4xx` range
  # indicate an error that failed given the information provided (e.g., a
  # required parameter
  # was omitted), and codes in the `5xx` range indicate an error with
  # Mailosaur's servers (give us a shout in the unlikely event that you see one
  # of those).
  #
  # | Code | Description |
  # |---|---|
  # | 200 - OK | Request was successful. |
  # | 204 - No Content | Request was successful, no response content. |
  # | 400 - Bad Request | The request could be handled, often due to missing a
  # required parameter. |
  # | 401 - Unauthorized | No valid API key provided. |
  # | 404 - Not Found | The requested resource doesn't exist. |
  # | 5XX - Server Errors | Something went wrong at Mailosaur. (Give us a
  # shout). |
  #
  # ## Error handling
  #
  # In of an error the server will return as much information as possible. In
  # the case of a `401` or
  # `404` error the status code gives as much information as you'd need. But
  # for `400` errors
  # Mailosaur will return a JSON object containing the structure below.
  #
  # Note that our client libraries convert responses to appropriate
  # language-specific objects.
  #
  # | Property | Description |
  # |---|---|
  # | `type` | The type of error returned. Can be: api_connection_error,
  # api_error, authentication_error, card_error, idempotency_error
  # invalid_request_error, or rate_limit_error. |
  # | `message` | A human-readable message providing more details about the
  # error. |
  # | `parameters` | A JSON object containing a key for each property name at
  # fault, with a human-readable message per field |
  # | `model` | The request model that we sent and failed to be processed |
  #
  class Analysis

    #
    # Creates and initializes a new instance of the Analysis class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [MailosaurBaseClient] reference to the MailosaurBaseClient
    attr_reader :client

    #
    # Perform a spam test
    #
    # Perform spam testing on the specified email
    #
    # @param email The identifier of the email to be analyzed.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SpamAnalysisResult] operation results.
    #
    def spam(email, custom_headers:nil)
      response = spam_async(email, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Perform a spam test
    #
    # Perform spam testing on the specified email
    #
    # @param email The identifier of the email to be analyzed.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def spam_with_http_info(email, custom_headers:nil)
      spam_async(email, custom_headers:custom_headers).value!
    end

    #
    # Perform a spam test
    #
    # Perform spam testing on the specified email
    #
    # @param email The identifier of the email to be analyzed.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def spam_async(email, custom_headers:nil)
      fail ArgumentError, 'email is nil' if email.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/analysis/spam/{email}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'email' => email},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::SpamAnalysisResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

  end
end
